import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState, AppThunk } from './store';
import { fetchNotes } from './notesApi';
import { notesListStatus } from './actionType';
import { Note } from '../types/note';
import { v4 as uuidv4 } from 'uuid';

/// Init State
export interface NotesListState {
    index: number;
    status: notesListStatus;
    notes: Note[];
}

const initialState: NotesListState = {
    index: 0,
    status: notesListStatus.idle,
    notes: [],
};

/// Async update function
// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const fetchNotesAsync = createAsyncThunk(
  'notesList/fetchNotes',
  async () => {
    const response = await fetchNotes();
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

/// Slice
export const notesListSlice = createSlice({
  name: 'notesList',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    addBlankNote: (state) => {
        const newNote: Note = {
        id: uuidv4(), 
        title: "{Note title}", 
        content: "{This is Note Content}", 
        date: new Date().toString(), 
        tags: []};
        state.notes = [...state.notes, newNote];
    },
    updateNote: (state, action: PayloadAction<Note>) => {
        let newNotes: Note[] = [];
        for (let note of state.notes) {
            if (note.id === action.payload.id) {
                newNotes.push(action.payload);
            } else {
                newNotes.push(note);
            }
        }
        state.notes = newNotes
    },
    setNotes: (state, action: PayloadAction<Note[]>) => {
        state.notes = action.payload;
    },
    // Use the PayloadAction type to declare the contents of `action.payload`
    incrementIndex: (state, action: PayloadAction<number>) => {
      state.index += action.payload;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(fetchNotesAsync.pending, (state) => {
        state.status = notesListStatus.loading;
      })
      .addCase(fetchNotesAsync.fulfilled, (state, action) => {
        state.status = notesListStatus.idle;
        state.notes = action.payload;
      })
      .addCase(fetchNotesAsync.rejected, (state) => {
        state.status = notesListStatus.failed;
      });
  },
});

export const { addBlankNote, updateNote, setNotes, incrementIndex } = notesListSlice.actions;

/// Selectors
// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectNotes = (state: RootState) => state.nodesList.notes;

/// Thunks functions
// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
// export const updateNote =
//   (updatedNote: Note): AppThunk =>
//   (dispatch, getState) => {
//     const notes = selectNotes(getState());

//     let newNotes: Note[] = [];
//     for (let note of notes) {
//         if (note.id === updatedNote.id) {
//             newNotes.push(updatedNote);
//         } else {
//             newNotes.push(note);
//         }
//     }
//     dispatch(setNotes(newNotes))
//   };

export default notesListSlice.reducer;