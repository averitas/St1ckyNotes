import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { CreateNotesAsync, FetchNotesAsync, UpdateNotesAsync } from './actions';
import { NotesListStatus } from './actionType';
import { Note, NotesSource } from '../types/note';
import { v4 as uuidv4 } from 'uuid';
import { NotesManager } from '../tools/notesManagers/notesManager';

var NotesManagerInst: NotesManager;

export const SetNotesManager = (mgr: NotesManager) => {
  NotesManagerInst = mgr;
}

export const GetNotesManager = () => NotesManagerInst

/// Init State
export interface NotesListState {
    index: number;
    status: NotesListStatus;
    notes: Note[];
    sourceType: NotesSource;
}

const initialState: NotesListState = {
    index: 0,
    status: NotesListStatus.idle,
    notes: [],
    sourceType: NotesSource.outlook,
};

/// Slice
export const notesListSlice = createSlice({
  name: 'notesList',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    addBlankNote: (state) => {
      const newNote: Note = {
        id: "", // Id that sync with remote.
        localId: uuidv4(), // a draft version of id. Will update when upload to remote.
        title: "{Note title}", 
        content: "{This is Note Content}",
        preview: "{This is Note Preview}",
        date: new Date().toISOString(), 
        tags: [],
        isDraft: true, // having uploaded to remote yet.
      };
      state.notes = [...state.notes, newNote];
    },
    updateNote: (state, action: PayloadAction<Note>) => {
        let newNotes: Note[] = [];
        for (let note of state.notes) {
            if (note.localId === action.payload.localId) {
                newNotes.push(action.payload);
            } else {
                newNotes.push(note);
            }
        }
        state.notes = newNotes
    },
    deleteNote: (state, action: PayloadAction<Note>) => {
      let newNotes: Note[] = [];
      for (let note of state.notes) {
          if (note.localId === action.payload.localId) {
              continue
          } else {
              newNotes.push(note);
          }
      }
      state.notes = newNotes
  },
    setNotes: (state, action: PayloadAction<Note[]>) => {
        state.notes = action.payload;
    },
    setNotesSource: (state, action: PayloadAction<NotesSource>) => {
      state.sourceType = action.payload;
    },
    // Use the PayloadAction type to declare the contents of `action.payload`
    incrementIndex: (state, action: PayloadAction<number>) => {
      state.index += action.payload;
    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(FetchNotesAsync.pending, (state) => {
        state.status = NotesListStatus.loading;
      })
      .addCase(FetchNotesAsync.fulfilled, (state, action) => {
        state.status = NotesListStatus.idle;
        state.notes = action.payload;
      })
      .addCase(FetchNotesAsync.rejected, (state) => {
        state.status = NotesListStatus.failed;
      })
      .addCase(UpdateNotesAsync.pending, (state) => {
        state.status = NotesListStatus.loading;
      })
      .addCase(UpdateNotesAsync.fulfilled, (state, action) => {
        state.status = NotesListStatus.idle;
      })
      .addCase(UpdateNotesAsync.rejected, (state) => {
        state.status = NotesListStatus.failed;
      })
      .addCase(CreateNotesAsync.pending, (state) => {
        state.status = NotesListStatus.loading;
      })
      .addCase(CreateNotesAsync.fulfilled, (state, action) => {
        state.status = NotesListStatus.idle;
      })
      .addCase(CreateNotesAsync.rejected, (state) => {
        state.status = NotesListStatus.failed;
      });
  },
});

export const { addBlankNote, updateNote, setNotes, incrementIndex, setNotesSource, deleteNote } = notesListSlice.actions;

export default notesListSlice.reducer;